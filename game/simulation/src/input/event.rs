use unit::world::{WorldPoint, WorldPosition};
use world::SliceRange;

use crate::InnerWorldRef;

#[derive(Debug, Copy, Clone)]
pub struct WorldColumn {
    // TODO NotNan these
    /// Must be non-NaN and finite
    pub x: f32,
    /// Must be non-NaN and finite
    pub y: f32,
    pub slice_range: SliceRange,
}

/// Event generated by the backend
#[derive(Debug)]
pub enum InputEvent {
    Click(SelectType, WorldColumn),
    /// (_, from ,to)
    Select(SelectType, WorldColumn, WorldColumn),
}

/// Resource for current mouse location in WORLD SPACE
#[derive(Default)]
pub struct MouseLocation(pub WorldPoint);

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum SelectType {
    Left,
    Right,
}

impl WorldColumn {
    pub fn find_min_max_walkable(
        &self,
        other: &Self,
        world: &InnerWorldRef,
    ) -> Option<(WorldPoint, WorldPoint)> {
        let range = self.slice_range;
        debug_assert_eq!(range, other.slice_range);

        let min = WorldColumn {
            x: self.x.min(other.x),
            y: self.y.min(other.y),
            slice_range: range,
        };

        let max = WorldColumn {
            x: self.x.max(other.x),
            y: self.y.max(other.y),
            slice_range: range,
        };

        min.find_highest_walkable(world)
            .zip(max.find_highest_walkable(world))
    }

    pub fn find_highest_walkable(&self, world: &InnerWorldRef) -> Option<WorldPoint> {
        let block = WorldPosition(
            self.x.floor() as i32,
            self.y.floor() as i32,
            self.slice_range.top(),
        );
        world
            .find_accessible_block_in_column_with_range(block, Some(self.slice_range.bottom()))
            .map(|WorldPosition(_, _, z)| {
                // only use z from result, keep input precision
                WorldPoint::new_unchecked(self.x, self.y, z.slice() as f32)
            })
    }
}
